var L=Object.defineProperty;var b=Object.getOwnPropertySymbols;var y=Object.prototype.hasOwnProperty,H=Object.prototype.propertyIsEnumerable;var u=(r,e,t)=>e in r?L(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,v=(r,e)=>{for(var t in e||(e={}))y.call(e,t)&&u(r,t,e[t]);if(b)for(var t of b(e))H.call(e,t)&&u(r,t,e[t]);return r};import{useEffect as T}from"react";function A(r,e,t,g=[],h={}){let{oneToOne:f=!1,callHandlerOnce:p=!1,callHandlerOnEach:O=!1,listenerOptions:c={}}=h,a=Array.isArray(e)?e:[e],d=Array.isArray(r)?r:[r];if(f&&d.length!==a.length)throw new Error("When oneToOne is set to false, the number of refs and events must be equal.");T(()=>{var E;let l=t();p&&l();let i=new AbortController,s=d.map(n=>n.current);if(f){for(let n=0;n<s.length;n++)O&&l(),(E=s[n])==null||E.addEventListener(a[n],l,v({signal:i.signal},c));return()=>i.abort()}for(let n of s)for(let o of a)O&&l(),n==null||n.addEventListener(o,l,v({signal:i.signal},c));return()=>{var n;if(!c.signal){i.abort();return}if(f){for(let o=0;o<s.length;o++)(n=s[o])==null||n.removeEventListener(a[o],l);return}for(let o of s)for(let m of a)o==null||o.removeEventListener(m,l)}},g)}export{A as default};
