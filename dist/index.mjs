var T=Object.defineProperty;var h=Object.getOwnPropertySymbols;var A=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable;var p=(t,e,n)=>e in t?T(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,O=(t,e)=>{for(var n in e||(e={}))A.call(e,n)&&p(t,n,e[n]);if(h)for(var n of h(e))k.call(e,n)&&p(t,n,e[n]);return t};import{useEffect as j}from"react";function w(t,e,n,L=[],m={}){let{oneToOne:c=!1,callHandlerOnce:y=!1,callHandlerOnEach:v=!1,listenerOptions:d={}}=m,a=Array.isArray(e)?e:[e],l=Array.isArray(t)?t:[t];if(c&&l.length!==a.length)throw new Error("When oneToOne is set to false, the number of refs and events must be equal.");j(()=>{var b,u,E;let s=n();y&&s();let i=new AbortController;if(c){for(let r=0;r<l.length;r++)v&&s(),(u=(b=l[r])==null?void 0:b.current)==null||u.addEventListener(a[r],s,O({signal:i.signal},d));return()=>i.abort()}for(let r of l)for(let f of a)v&&s(),(E=r==null?void 0:r.current)==null||E.addEventListener(f,s,O({signal:i.signal},d));return()=>{var r,f,g;if(d.signal)if(c)for(let o=0;o<l.length;o++)(f=(r=l[o])==null?void 0:r.current)==null||f.removeEventListener(a[o],s);else for(let o of l)for(let H of a)(g=o==null?void 0:o.current)==null||g.removeEventListener(H,s);else i.abort()}},L)}export{w as default};
